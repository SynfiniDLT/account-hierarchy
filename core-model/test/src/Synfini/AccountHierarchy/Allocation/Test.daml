-- Copyright (c) 2022 ASX Operations Pty Ltd. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# LANGUAGE ApplicativeDo #-}

module Synfini.AccountHierarchy.Allocation.Test where

import DA.Assert ((===))
import DA.Finance.Asset
import DA.Finance.Types
import qualified DA.Map as Map
import qualified DA.Optional as O
import qualified DA.Set as Set
import Daml.Script
import Synfini.AccountHierarchy.Allocation
import Synfini.AccountHierarchy.Custody
import Synfini.AccountHierarchy.TestUtils

test_AllocationChangeInstruction_observers : Script ()
test_AllocationChangeInstruction_observers = withParties $ \parties -> do
  let deallocation = DeallocationDetails with
        account = acc parties.alice parties.fred parties.fred
        depositCid = None
  let allocation = AllocationDetails with
        account = acc parties.bob parties.fred parties.fred
        confirmed = False
  let asset = Asset with
        id = Id Set.empty "a" 0
        quantity = 1.0
  let masterAgreement = MasterAgreement with
        id = Id (Set.fromList [parties.fred]) "m" 0
        party1 = parties.charlie
        party2 = parties.david
  let allocationChangeInstruction = AllocationChangeInstruction with
        asset
        masterAgreement
        tradeId = Id (Set.fromList [parties.fred]) "t" 0
        deallocations = [deallocation]
        allocations = [allocation]
        observers = Set.fromList [parties.eve]
  Set.fromList (observer allocationChangeInstruction) === Set.fromList [
      parties.alice,
      parties.bob, 
      parties.charlie,
      parties.david,
      parties.eve
    ]

account_ab, account_bc, account_cd, account_de : Parties -> Account
account_ab parties = acc parties.alice parties.alice parties.bob
account_bc parties = acc parties.bob parties.bob parties.charlie
account_cd parties = acc parties.charlie parties.charlie parties.david
account_de parties = acc parties.david parties.david parties.eve

assetId_x, assetId_y : Id
assetId_x = Id with
  signatories = Set.empty
  label = "x"
  version = 0
assetId_y = Id with
  signatories = Set.empty
  label = "y"
  version = 0

asset_x : Decimal -> Asset
asset_x quantity = Asset with
  id = assetId_x
  quantity

deposit_bc_x, deposit_cd_x, deposit_de_x, deposit_bc_y : Parties -> Decimal -> AssetDeposit
deposit_bc_x parties quantity = AssetDeposit with
  asset = Asset with
    id = assetId_x
    quantity
  account = account_bc parties
  observers = Set.fromList [parties.alice, parties.bob, parties.charlie, parties.david, parties.eve, parties.fred]
deposit_cd_x parties quantity = (deposit_bc_x parties quantity) with account = account_cd parties
deposit_de_x parties quantity = (deposit_bc_x parties quantity) with account = account_de parties
deposit_bc_y parties quantity = (deposit_bc_x parties quantity) with asset.id = assetId_y

test_AllocationChangeInstruction_singleDeallocation : Script ()
test_AllocationChangeInstruction_singleDeallocation = withParties $ \parties -> do
  let custodyAgreement = CustodyAgreement with
        parent = account_ab parties
        account = account_bc parties
        observers = Set.fromList [parties.charlie]
  let deallocation = DeallocationDetails with
        account = account_bc parties
        depositCid = None
  let deposit_bc_x_1 = deposit_bc_x parties 1.0
  let masterAgreement = MasterAgreement with
        id = Id (Set.fromList [parties.alice]) "m" 0
        party1 = parties.charlie
        party2 = parties.david
  let allocationChangeInstruction = AllocationChangeInstruction with
        asset = deposit_bc_x_1.asset
        masterAgreement
        tradeId = Id Set.empty "t" 0
        deallocations = [deallocation]
        allocations = []
        observers = Set.empty

  submitMulti [parties.alice, parties.bob] [] do createCmd custodyAgreement
  depositCid <- submit parties.bob do createCmd (deposit_bc_x parties 1.0)
  depositCid_badQuantity <- submit parties.bob do createCmd (deposit_bc_x parties 1.1)
  depositCid_badAssetId <- submit parties.bob do createCmd (deposit_bc_y parties 1.0)
  depositCid_badAccount <- submit parties.charlie do createCmd (deposit_cd_x parties 1.0)

  submit parties.alice do createCmd allocationChangeInstruction
  submitMustFail parties.bob do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextDeallocation with
      depositCid = depositCid_badQuantity
  submitMustFail parties.bob do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextDeallocation with
      depositCid = depositCid_badAssetId
  submitMustFail parties.bob do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextDeallocation with
      depositCid = depositCid_badAccount
  submit parties.bob do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextDeallocation with
      depositCid = depositCid
  result <- submit parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_Process
  result === []
  depositCids <- fmap fst <$> query @AssetDeposit (stakeholder allocationChangeInstruction)
  Set.fromList depositCids === Set.fromList [depositCid_badQuantity, depositCid_badAssetId, depositCid_badAccount]

test_AllocationChangeInstruction_multipleDeallocation : Script ()
test_AllocationChangeInstruction_multipleDeallocation = withParties $ \parties -> do
  let custodyAgreement1 = CustodyAgreement with
        parent = account_ab parties
        account = account_bc parties
        observers = Set.fromList [parties.alice]
  let custodyAgreement2 = CustodyAgreement with
        parent = account_bc parties
        account = account_cd parties
        observers = Set.fromList [parties.alice]
  let deallocation1 = DeallocationDetails with
        account = account_bc parties
        depositCid = None
  let deallocation2 = DeallocationDetails with
        account = account_cd parties
        depositCid = None
  let deposit_bc_x_1 = deposit_bc_x parties 1.0
  let deposit_cd_x_1 = deposit_cd_x parties 1.0
  let masterAgreement = MasterAgreement with
        id = Id (Set.fromList [parties.alice]) "m" 0
        party1 = parties.charlie
        party2 = parties.david
  let allocationChangeInstruction = AllocationChangeInstruction with
        asset = deposit_bc_x_1.asset
        masterAgreement
        tradeId = Id Set.empty "t" 0
        deallocations = [deallocation2, deallocation1]
        allocations = []
        observers = Set.empty

  submitMulti [parties.alice, parties.bob, parties.charlie, parties.david] [] $
    createCmd custodyAgreement1 *>
    createCmd custodyAgreement2
  depositCid1 <- submit parties.bob do createCmd deposit_bc_x_1
  depositCid2 <- submit parties.charlie do createCmd deposit_cd_x_1

  submit parties.alice do createCmd allocationChangeInstruction
  submitMustFail parties.bob do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextDeallocation with
      depositCid = depositCid1
  submit parties.charlie do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextDeallocation with
      depositCid = depositCid2
  submit parties.bob do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextDeallocation with
      depositCid = depositCid1
  result <- submit parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_Process
  result === []
  deposits <- query @AssetDeposit (stakeholder allocationChangeInstruction)
  deposits === []

-- Invalid tree scenarios:
-- Deallocate or allocate with non-leaf terminal node
-- Deallocate and allocate without common parent
-- Deallocate or allocate without going up to the root

test_AllocationChangeInstruction_invalidTreeStructure : Script ()
test_AllocationChangeInstruction_invalidTreeStructure = withParties $ \parties -> do
  let custodyAgreement1 = CustodyAgreement with
        parent = account_ab parties
        account = account_bc parties
        observers = Set.fromList [parties.alice]
  let custodyAgreement2 = CustodyAgreement with
        parent = account_bc parties
        account = account_cd parties
        observers = Set.fromList [parties.alice]
  let custodyAgreement3 = CustodyAgreement with
        parent = account_cd parties
        account = account_de parties
        observers = Set.fromList [parties.alice]
  let davidCustodianRole = CustodianRole with
        parent = account_cd parties
        observers = Set.fromList [parties.alice]
  depositCid_bc_x_1 <- submit parties.bob do createCmd $ deposit_bc_x parties 1.0
  depositCid_cd_x_1 <- submit parties.charlie do createCmd $ deposit_cd_x parties 1.0
  depositCid_de_x_1 <- submit parties.david do createCmd $ deposit_de_x parties 1.0
  let deallocation1 = DeallocationDetails with
        account = account_bc parties
        depositCid = Some depositCid_bc_x_1
  let deallocation2 = DeallocationDetails with
        account = account_cd parties
        depositCid = Some depositCid_cd_x_1
  let deallocation3 = DeallocationDetails with
        account = account_de parties
        depositCid = Some depositCid_de_x_1
  let allocation1 = AllocationDetails with
        account = deallocation1.account
        confirmed = True
  let allocation2 = AllocationDetails with
        account = deallocation2.account
        confirmed = True
  let allocation3 = AllocationDetails with
        account = deallocation3.account
        confirmed = True
  let masterAgreement = MasterAgreement with
        id = Id (Set.fromList [parties.alice]) "m" 0
        party1 = parties.charlie
        party2 = parties.david
  let deallocateInstruction = AllocationChangeInstruction with
        asset = asset_x 1.0
        masterAgreement
        tradeId = Id Set.empty "deallocate" 0
        deallocations = [deallocation3, deallocation2, deallocation1]
        allocations = []
        observers = Set.empty
  let deallocateInstruction_noLeaf = deallocateInstruction with
        tradeId.label = "deallocate.noLeaf"
        deallocations = [deallocation2, deallocation1]
  let deallocateInstruction_missingTop = deallocateInstruction with
        tradeId.label = "deallocate.missingTop"
        deallocations = [deallocation3, deallocation2]
  let deallocateInstruction_wrongStructure = deallocateInstruction with
        tradeId.label = "deallocate.wrongStructure"
        deallocations = [deallocation2, deallocation3, deallocation1]
  let allocateInstruction = AllocationChangeInstruction with
        asset = asset_x 1.0
        masterAgreement
        tradeId = Id Set.empty "allocate" 0
        deallocations = []
        allocations = [allocation1, allocation2, allocation3]
        observers = Set.empty
  let allocateInstruction_noLeaf = allocateInstruction with
        tradeId.label = "allocate.noLeaf"
        allocations = [allocation1, allocation2]
  let allocateInstruction_missingTop = allocateInstruction with
        tradeId.label = "allocate.missingTop"
        allocations = [allocation2, allocation3]
  let allocateInstruction_wrongStructure = allocateInstruction with
        tradeId.label = "allocate.wrongStructure"
        allocations = [allocation1, allocation3, allocation2]

  submitMulti [parties.alice, parties.bob, parties.charlie, parties.david] [] do
    createCmd custodyAgreement1
    createCmd custodyAgreement2
    createCmd custodyAgreement3
    createCmd davidCustodianRole
    createCmd deallocateInstruction
    createCmd deallocateInstruction_noLeaf
    createCmd deallocateInstruction_missingTop
    createCmd deallocateInstruction_wrongStructure
    createCmd allocateInstruction
    createCmd allocateInstruction_noLeaf
    createCmd allocateInstruction_missingTop
    createCmd allocateInstruction_wrongStructure
    pure ()

  submitMustFail parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key deallocateInstruction_noLeaf) AllocationChangeInstruction_Process
  submitMustFail parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key deallocateInstruction_missingTop) AllocationChangeInstruction_Process
  submitMustFail parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key deallocateInstruction_wrongStructure) AllocationChangeInstruction_Process
  submit parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key deallocateInstruction) AllocationChangeInstruction_Process

  submitMustFail parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocateInstruction_noLeaf) AllocationChangeInstruction_Process
  submitMustFail parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocateInstruction_missingTop) AllocationChangeInstruction_Process
  submitMustFail parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocateInstruction_wrongStructure) AllocationChangeInstruction_Process
  submit parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocateInstruction) AllocationChangeInstruction_Process
  pure ()

test_AllocationChangeInstruction_singleAllocation : Script ()
test_AllocationChangeInstruction_singleAllocation = withParties $ \parties -> do
  let custodyAgreement = CustodyAgreement with
        parent = account_ab parties
        account = account_bc parties
        observers = Set.fromList [parties.charlie]
  let allocation = AllocationDetails with
        account = account_bc parties
        confirmed = False
  let deposit_bc_x_1 = deposit_bc_x parties 1.0
  let masterAgreement = MasterAgreement with
        id = Id (Set.fromList [parties.alice]) "m" 0
        party1 = parties.charlie
        party2 = parties.david
  let allocationChangeInstruction = AllocationChangeInstruction with
        asset = deposit_bc_x_1.asset
        masterAgreement
        tradeId = Id Set.empty "t" 0
        deallocations = []
        allocations = [allocation]
        observers = Set.empty

  submitMulti [parties.alice, parties.bob] [] do createCmd custodyAgreement

  submit parties.alice do createCmd allocationChangeInstruction
  submit parties.bob do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextAllocation
  [resultCid] <- submit parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_Process
  [(depositCid, deposit)] <- query @AssetDeposit (stakeholder allocationChangeInstruction)
  depositCid === resultCid
  deposit.asset === allocationChangeInstruction.asset
  deposit.account === allocation.account

test_AllocationChangeInstruction_multipleAllocation : Script ()
test_AllocationChangeInstruction_multipleAllocation = withParties $ \parties -> do
  let custodyAgreement1 = CustodyAgreement with
        parent = account_ab parties
        account = account_bc parties
        observers = Set.fromList [parties.alice]
  let custodyAgreement2 = CustodyAgreement with
        parent = account_bc parties
        account = account_cd parties
        observers = Set.fromList [parties.alice]
  let allocation1 = AllocationDetails with
        account = account_bc parties
        confirmed = False
  let allocation2 = AllocationDetails with
        account = account_cd parties
        confirmed = False
  let masterAgreement = MasterAgreement with
        id = Id (Set.fromList [parties.alice]) "m" 0
        party1 = parties.charlie
        party2 = parties.david
  let allocationChangeInstruction = AllocationChangeInstruction with
        asset = asset_x 1.0
        masterAgreement
        tradeId = Id Set.empty "t" 0
        deallocations = []
        allocations = [allocation1, allocation2]
        observers = Set.empty

  submitMulti [parties.alice, parties.bob, parties.charlie, parties.david] [] do
    createCmd custodyAgreement1
    createCmd custodyAgreement2
    pure ()

  submit parties.alice do createCmd allocationChangeInstruction
  submitMustFail parties.charlie do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextAllocation
  submit parties.bob do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextAllocation
  submit parties.charlie do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_ConfirmNextAllocation

  resultCids@[resultCid1, resultCid2] <- submit parties.alice do
    exerciseByKeyCmd @AllocationChangeInstruction (key allocationChangeInstruction) AllocationChangeInstruction_Process
  depositsMap <- Map.fromList <$> query @AssetDeposit (stakeholder allocationChangeInstruction)

  Set.fromList (Map.keys depositsMap) === Set.fromList resultCids
  let deposit1 = O.fromSome $ Map.lookup resultCid1 depositsMap
      deposit2 = O.fromSome $ Map.lookup resultCid2 depositsMap
  deposit1.account === allocation1.account
  deposit1.asset === allocationChangeInstruction.asset
  deposit2.account === allocation2.account
  deposit2.asset === allocationChangeInstruction.asset
